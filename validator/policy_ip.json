import re, json, sys, pathlib

def parse_oracle_ctx(text, extractors):
    ctx = {"schema":"<SCHEMA>", "table":"<TABLE>", "columns": []}
    ct = re.search(extractors["oracle"]["create_table"], text, re.I|re.S)
    if ct:
        schema, table, cols_block = ct.group(1), ct.group(2), ct.group(3)
        if schema: ctx["schema"] = schema
        if table:  ctx["table"]  = table
        cols = re.findall(extractors["oracle"]["column_def"], cols_block, re.I)
        # solo nombres, no inventar
        ctx["columns"] = [c[0] for c in cols]
    return ctx

def binding_from_ctx(rule_id, ctx, assist):
    b = {}
    if rule_id == "ORC-SELECT-NO-STAR":
        b["table"] = ctx.get("table","<TABLE>")
        if ctx.get("columns"):
            b["columns_or_placeholder"] = ", ".join(ctx["columns"])
        else:
            b["columns_or_placeholder"] = "<col1, col2, ...>"
    elif rule_id == "ORC-PK-EXISTS":
        b["schema"] = ctx.get("schema","<SCHEMA>")
        b["table"]  = ctx.get("table","<TABLE>")
        # Nunca inventar columnas de PK
        b["pk_cols"] = "<PK_COL1, PK_COL2, ...>"
    elif rule_id == "ORC-TABLE-OPTIONS":
        tbs = (((assist.get("defaults") or {}).get("oracle") or {}).get("tablespace")) or "<TABLESPACE>"
        b["tablespace"] = tbs
    elif rule_id == "ORC-IDX-NAME":
        # firstcol se toma del ON (...) si la regla la capturó; si no, placeholder
        b["table"] = ctx.get("table","<TABLE>")
        b["firstcol"] = ctx["columns"][0] if ctx.get("columns") else "<COL>"
    return b
:true,"severity":"error","cite":"IPC §Parámetros"}
      ]
    }
  ]
}
