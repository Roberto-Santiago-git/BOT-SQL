import sys, json, re, pathlib, urllib.request, os, fnmatch

FLAGS = re.I | re.M | re.S

# ---------- Heurísticas sin fences ----------
SQL_TOKENS = r"(?is)\b(CREATE|ALTER|COMMENT|GRANT|REVOKE|DROP|SELECT|INSERT|UPDATE|DELETE)\b|(?is)\bPARTITION\s+BY\b"
IPC_TOKENS = r"(?im)^\s*\[Global\]\b|(?s)\$\$PM_|(?s)\$\$PW_"
PS_TOKENS  = r"(?im)^\s*(Clear-Host|param\(|Write-Output|Get-ChildItem|Set-Content)\b"
XML_TOKENS = r"(?is)<\?xml|<partition\s+name="

def looks_like_code(text):
    return any(re.search(p, text) for p in (SQL_TOKENS, IPC_TOKENS, PS_TOKENS, XML_TOKENS))

def guess_inline_name(text):
    if re.search(XML_TOKENS, text): return "inline.xml"
    if re.search(PS_TOKENS,  text): return "inline.ps1"
    if re.search(IPC_TOKENS, text): return "inline.prm"
    return "inline.sql"

# ---------- IO ----------
def _read_text(path_or_url):
    # URL
    if path_or_url.startswith(("http://", "https://")):
        with urllib.request.urlopen(path_or_url) as r:
            return r.read().decode("utf-8")
    # Archivo
    p = pathlib.Path(path_or_url)
    if p.exists():
        return p.read_text(encoding="utf-8", errors="ignore")
    # Inline literal (sin fences)
    if looks_like_code(path_or_url):
        return path_or_url
    # Stdin si pidieron "-"
    if path_or_url == "-":
        data = sys.stdin.read()
        if data:
            return data
    # Sin artefacto
    return None

def load_policy(path_or_url):
    data = json.loads(_read_text(path_or_url))
    return data, data.get("assist", {})

# ---------- CONTEXTO ORACLE (no inventar) ----------
def parse_oracle_ctx(text, extractors):
    ctx = {"schema": "<SCHEMA>", "table": "<TABLE>", "columns": []}
    oracle_ext = (extractors or {}).get("oracle", {}) if extractors else {}

    ct_pat = oracle_ext.get("create_table", "")
    if ct_pat:
        ct = re.search(ct_pat, text or "", FLAGS)
        if ct:
            schema, table, cols_block = ct.group(1), ct.group(2), ct.group(3)
            if schema: ctx["schema"] = schema
            if table:  ctx["table"]  = table
            col_pat = oracle_ext.get("column_def", "")
            if col_pat:
                cols = re.findall(col_pat, cols_block or "", FLAGS)
                ctx["columns"] = [c[0] for c in cols]

    pk_pat = oracle_ext.get("partition_key", "")
    if pk_pat:
        pk = re.search(pk_pat, text or "", FLAGS)
        if pk:
            ctx["partcol"] = pk.group(1)
    return ctx

# ---------- BINDINGS PARA FIX ----------
def binding_from_ctx(rule_id, ctx, assist):
    b = {}
    if rule_id == "ORC-SELECT-NO-STAR":
        b["table"] = ctx.get("table", "<TABLE>")
        b["columns_or_placeholder"] = ", ".join(ctx["columns"]) if ctx.get("columns") else "<col1, col2, ...>"
    elif rule_id == "ORC-PK-EXISTS":
        b["schema"] = ctx.get("schema", "<SCHEMA>")
        b["table"]  = ctx.get("table", "<TABLE>")
        b["pk_cols"] = "<PK_COL1, PK_COL2, ...>"
    elif rule_id == "ORC-TABLE-OPTIONS":
        tbs = (((assist.get("defaults") or {}).get("oracle") or {}).get("tablespace")) or "<TABLESPACE>"
        b["tablespace"] = tbs
    elif rule_id == "ORC-IDX-NAME":
        b["table"] = ctx.get("table", "<TABLE>")
        b["firstcol"] = ctx["columns"][0] if ctx.get("columns") else "<COL>"
    elif rule_id in ("ORC-PART-NAME", "XML-PART-NAME"):
        b["partcol"] = ctx.get("partcol", "<COL>")
        b["suffix"]  = "<SUFFIX>"
    elif rule_id == "ORC-GRANT-FQN":
        b["schema"]  = ctx.get("schema", "<SCHEMA>")
    return b

# ---------- RENDER DEL FIX ----------
def _sub_template_vars(tpl, bind):
    out = tpl
    for k, v in bind.items():
        out = out.replace("${" + k + "}", v)
    return out

def render_fix(rule, text, ctx, assist, first_match):
    fx = rule.get("fix") or {}
    if not fx:
        return None

    bind = binding_from_ctx(rule["id"], ctx, assist)

    # usar el token incumplido como sufijo en particiones (SQL y XML)
    if rule["id"] in ("ORC-PART-NAME", "XML-PART-NAME") and first_match:
        offending = first_match.group(1)
        if re.fullmatch(r"[A-Za-z0-9_]{1,30}", offending):
            bind["suffix"] = offending

    tpl = fx.get("template", "")
    tpl = _sub_template_vars(tpl, bind)

    loc = fx.get("locator")
    if loc:
        m = re.search(loc, text or "", FLAGS)
        if m:
            last = m.lastindex or 0
            for i in range(1, last + 1):
                tpl = tpl.replace("${g" + str(i) + "}", m.group(i))
            if last >= 1 and m.group(1) is not None:
                tpl = tpl.replace("${block}", m.group(1))

    return tpl.strip() if tpl else None

# ---------- EVALUACIÓN ----------
def eval_rules(text, ns, ctx, assist):
    violations = []
    for r in ns.get("rules", []):
        pat = re.compile(r.get("pattern", ""), FLAGS)
        must = r.get("must_match", False)
        invert = r.get("invert", False)
        fx = r.get("fix", {}) or {}
        apply_global = (fx.get("apply") == "global") or (fx.get("multiple") is True)

        matches = list(pat.finditer(text or "")) if apply_global else [pat.search(text or "")]
        has_hit = any(bool(m) for m in matches if m)

        hit = has_hit
        if invert:
            hit = not hit
        violated = (not hit) if must else hit

        if not violated:
            continue

        if apply_global and matches:
            for m in matches:
                if not m:
                    continue
                fix = render_fix(r, text, ctx, assist, m)
                violations.append({
                    "id": r["id"],
                    "desc": r["desc"],
                    "severity": r.get("severity", "warn"),
                    "cite": r.get("cite"),
                    "quote": r.get("quote"),
                    "fix": fix
                })
